// Package orchardclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package orchardclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ClusterSettingsSchedulerProfile.
const (
	DistributeLoad      ClusterSettingsSchedulerProfile = "distribute-load"
	OptimizeUtilization ClusterSettingsSchedulerProfile = "optimize-utilization"
)

// Defines values for VMImagePullPolicy.
const (
	VMImagePullPolicyAlways       VMImagePullPolicy = "Always"
	VMImagePullPolicyIfNotPresent VMImagePullPolicy = "IfNotPresent"
)

// Defines values for VMRestartPolicy.
const (
	VMRestartPolicyNever     VMRestartPolicy = "Never"
	VMRestartPolicyOnFailure VMRestartPolicy = "OnFailure"
)

// Defines values for VMStatus.
const (
	VMStatusFailed  VMStatus = "failed"
	VMStatusPending VMStatus = "pending"
	VMStatusRunning VMStatus = "running"
)

// Defines values for VMSpecImagePullPolicy.
const (
	VMSpecImagePullPolicyAlways       VMSpecImagePullPolicy = "Always"
	VMSpecImagePullPolicyIfNotPresent VMSpecImagePullPolicy = "IfNotPresent"
)

// Defines values for VMSpecRestartPolicy.
const (
	VMSpecRestartPolicyNever     VMSpecRestartPolicy = "Never"
	VMSpecRestartPolicyOnFailure VMSpecRestartPolicy = "OnFailure"
)

// Defines values for VMStateStatus.
const (
	VMStateStatusFailed  VMStateStatus = "failed"
	VMStateStatusPending VMStateStatus = "pending"
	VMStateStatusRunning VMStateStatus = "running"
)

// Defines values for PostVmsJSONBodyImagePullPolicy.
const (
	Always       PostVmsJSONBodyImagePullPolicy = "Always"
	IfNotPresent PostVmsJSONBodyImagePullPolicy = "IfNotPresent"
)

// Defines values for PostVmsJSONBodyRestartPolicy.
const (
	Never     PostVmsJSONBodyRestartPolicy = "Never"
	OnFailure PostVmsJSONBodyRestartPolicy = "OnFailure"
)

// ClusterSettings defines model for ClusterSettings.
type ClusterSettings struct {
	// HostDirPolicies If not empty, allows instantiating VMs with `hostDirs` that match the policies
	// listed in this array.
	HostDirPolicies *[]struct {
		PathPrefix *string `json:"pathPrefix,omitempty"`
		Ro         *bool   `json:"ro,omitempty"`
	} `json:"hostDirPolicies,omitempty"`

	// SchedulerProfile Scheduler profile to use. Possible values:
	//
	// * `optimize-utilization` — when scheduling a pending VM to a worker, pick the busiest worker
	// that can fit a VM first, falling back to less busier workers (this is the default behavior
	// when no explicit scheduler profile is set)
	//
	// * `distribute-load` — when scheduling a pending VM to a worker, pick the least occupied worker
	// that can fit a VM first, falling back to more busier workers
	SchedulerProfile *ClusterSettingsSchedulerProfile `json:"schedulerProfile,omitempty"`
}

// ClusterSettingsSchedulerProfile Scheduler profile to use. Possible values:
//
// * `optimize-utilization` — when scheduling a pending VM to a worker, pick the busiest worker
// that can fit a VM first, falling back to less busier workers (this is the default behavior
// when no explicit scheduler profile is set)
//
// * `distribute-load` — when scheduling a pending VM to a worker, pick the least occupied worker
// that can fit a VM first, falling back to more busier workers
type ClusterSettingsSchedulerProfile string

// ControllerInfo defines model for ControllerInfo.
type ControllerInfo struct {
	// Capabilities Supported capabilities
	Capabilities *[]string `json:"capabilities,omitempty"`

	// Commit Commit hash
	Commit *string `json:"commit,omitempty"`

	// Version Version number
	Version *string `json:"version,omitempty"`
}

// Event defines model for Event.
type Event struct {
	// Kind Kind of the event
	Kind *string `json:"kind,omitempty"`

	// Payload Payload of the event
	Payload *string `json:"payload,omitempty"`

	// Timestamp Unix timestamp of the event
	Timestamp *int `json:"timestamp,omitempty"`
}

// Events defines model for Events.
type Events = map[string]interface{}

// IP defines model for IP.
type IP struct {
	// Ip The resolved IP address
	Ip *string `json:"ip,omitempty"`
}

// ServiceAccount defines model for ServiceAccount.
type ServiceAccount struct {
	// Name Name
	Name  *string   `json:"name,omitempty"`
	Roles *[]string `json:"roles,omitempty"`

	// Token Secret token used to access the API
	Token *string `json:"token,omitempty"`
}

// VM defines model for VM.
type VM struct {
	// Cpu Number of CPUs assigned to this VM
	Cpu *float32 `json:"cpu,omitempty"`

	// DiskSize Disk size for this VM
	DiskSize *float32 `json:"diskSize,omitempty"`

	// Generation Incremented by the controller each time a VM's specification changes
	Generation *float32 `json:"generation,omitempty"`

	// Headless Whether to run without graphics
	Headless *bool `json:"headless,omitempty"`

	// HostDirs Directories on the Orchard Worker host to mount to a VM
	HostDirs *[]struct {
		Name *string `json:"name,omitempty"`
		Path *string `json:"path,omitempty"`
		Ro   *bool   `json:"ro,omitempty"`
	} `json:"hostDirs,omitempty"`

	// Image VM image for this VM
	Image *string `json:"image,omitempty"`

	// ImagePullPolicy VM image pull policy
	ImagePullPolicy *VMImagePullPolicy `json:"imagePullPolicy,omitempty"`

	// Labels Labels required by this VM on the worker
	Labels *map[string]string `json:"labels,omitempty"`

	// Memory Amount of RAM in megabytes assigned to this VM
	Memory *float32 `json:"memory,omitempty"`

	// Name VM name
	Name *string `json:"name,omitempty"`

	// Nested Enable nested virtualization
	Nested *bool `json:"nested,omitempty"`

	// NetBridged Whether to use bridged network mode
	NetBridged *string `json:"net-bridged,omitempty"`

	// NetSoftnetDeprecated Please use `NetSoftnet` instead
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	NetSoftnetDeprecated *bool `json:"net-softnet,omitempty"`

	// NetSoftnet Whether to use Softnet network isolation.
	//
	// See `tart run`'s help for `--net-softnet` for more details.
	NetSoftnet *bool `json:"netSoftnet,omitempty"`

	// NetSoftnetAllow List of CIDRs to allow the traffic to when using Softnet isolation.
	//
	// See `tart run`'s help for `--net-softnet-allow` for more details.
	//
	// Enables `netSoftnet`.
	NetSoftnetAllow *[]string `json:"netSoftnetAllow,omitempty"`

	// NetSoftnetBlock List of CIDRs to block the traffic to when using Softnet isolation.
	//
	// See `tart run`'s help for `--net-softnet-block` for more details.
	//
	// Enables `netSoftnet`.
	NetSoftnetBlock *[]string `json:"netSoftnetBlock,omitempty"`

	// ObservedGeneration Corresponds to the `Generation` value on which the worker had acted upon
	ObservedGeneration *float32 `json:"observedGeneration,omitempty"`

	// Password SSH password to use when connecting to a VM
	Password *string `json:"password,omitempty"`

	// Resources Resources required by this VM on the worker
	Resources *map[string]int `json:"resources,omitempty"`

	// RestartPolicy VM restart policy: specify "Never" to never restart or "OnFailure" to only restart when the VM fails
	RestartPolicy *VMRestartPolicy `json:"restart_policy,omitempty"`

	// StartupScript Startup script to run after the VM boots and becomes accessible via SSH
	StartupScript *struct {
		Env           *map[string]string `json:"env,omitempty"`
		ScriptContent *string            `json:"script_content,omitempty"`
	} `json:"startup_script,omitempty"`

	// Status VM status
	Status *VMStatus `json:"status,omitempty"`

	// StatusMessage VM status message
	StatusMessage *string `json:"status_message,omitempty"`

	// Suspendable When set, a VM will be started with an additional
	// `--suspendable` command-line argument to `tart run`,
	// which allows suspending it.
	//
	// Further generations of the VM will be `tart suspend`'ed instead of
	// `tart stopped`.
	//
	// For example, this allows you to prepare a VM with loose Softnet settings and then
	// move to the next generation by tightening the settings while preserving the VM's state.
	Suspendable *bool `json:"suspendable,omitempty"`

	// Username SSH username to use when connecting to a VM
	Username *string `json:"username,omitempty"`

	// Worker Worker on which the VM was assigned to
	Worker *string `json:"worker,omitempty"`
}

// VMImagePullPolicy VM image pull policy
type VMImagePullPolicy string

// VMRestartPolicy VM restart policy: specify "Never" to never restart or "OnFailure" to only restart when the VM fails
type VMRestartPolicy string

// VMStatus VM status
type VMStatus string

// VMMeta defines model for VMMeta.
type VMMeta struct {
	// Generation Incremented by the controller each time a VM's specification changes
	Generation *float32 `json:"generation,omitempty"`

	// Name VM name
	Name *string `json:"name,omitempty"`
}

// VMSpec defines model for VMSpec.
type VMSpec struct {
	// Cpu Number of CPUs assigned to this VM
	Cpu *float32 `json:"cpu,omitempty"`

	// DiskSize Disk size for this VM
	DiskSize *float32 `json:"diskSize,omitempty"`

	// Headless Whether to run without graphics
	Headless *bool `json:"headless,omitempty"`

	// HostDirs Directories on the Orchard Worker host to mount to a VM
	HostDirs *[]struct {
		Name *string `json:"name,omitempty"`
		Path *string `json:"path,omitempty"`
		Ro   *bool   `json:"ro,omitempty"`
	} `json:"hostDirs,omitempty"`

	// Image VM image for this VM
	Image *string `json:"image,omitempty"`

	// ImagePullPolicy VM image pull policy
	ImagePullPolicy *VMSpecImagePullPolicy `json:"imagePullPolicy,omitempty"`

	// Labels Labels required by this VM on the worker
	Labels *map[string]string `json:"labels,omitempty"`

	// Memory Amount of RAM in megabytes assigned to this VM
	Memory *float32 `json:"memory,omitempty"`

	// Nested Enable nested virtualization
	Nested *bool `json:"nested,omitempty"`

	// NetBridged Whether to use bridged network mode
	NetBridged *string `json:"net-bridged,omitempty"`

	// NetSoftnetDeprecated Please use `NetSoftnet` instead
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	NetSoftnetDeprecated *bool `json:"net-softnet,omitempty"`

	// NetSoftnet Whether to use Softnet network isolation.
	//
	// See `tart run`'s help for `--net-softnet` for more details.
	NetSoftnet *bool `json:"netSoftnet,omitempty"`

	// NetSoftnetAllow List of CIDRs to allow the traffic to when using Softnet isolation.
	//
	// See `tart run`'s help for `--net-softnet-allow` for more details.
	//
	// Enables `netSoftnet`.
	NetSoftnetAllow *[]string `json:"netSoftnetAllow,omitempty"`

	// NetSoftnetBlock List of CIDRs to block the traffic to when using Softnet isolation.
	//
	// See `tart run`'s help for `--net-softnet-block` for more details.
	//
	// Enables `netSoftnet`.
	NetSoftnetBlock *[]string `json:"netSoftnetBlock,omitempty"`

	// Password SSH password to use when connecting to a VM
	Password *string `json:"password,omitempty"`

	// Resources Resources required by this VM on the worker
	Resources *map[string]int `json:"resources,omitempty"`

	// RestartPolicy VM restart policy: specify "Never" to never restart or "OnFailure" to only restart when the VM fails
	RestartPolicy *VMSpecRestartPolicy `json:"restart_policy,omitempty"`

	// StartupScript Startup script to run after the VM boots and becomes accessible via SSH
	StartupScript *struct {
		Env           *map[string]string `json:"env,omitempty"`
		ScriptContent *string            `json:"script_content,omitempty"`
	} `json:"startup_script,omitempty"`

	// Suspendable When set, a VM will be started with an additional
	// `--suspendable` command-line argument to `tart run`,
	// which allows suspending it.
	//
	// Further generations of the VM will be `tart suspend`'ed instead of
	// `tart stopped`.
	//
	// For example, this allows you to prepare a VM with loose Softnet settings and then
	// move to the next generation by tightening the settings while preserving the VM's state.
	Suspendable *bool `json:"suspendable,omitempty"`

	// Username SSH username to use when connecting to a VM
	Username *string `json:"username,omitempty"`
}

// VMSpecImagePullPolicy VM image pull policy
type VMSpecImagePullPolicy string

// VMSpecRestartPolicy VM restart policy: specify "Never" to never restart or "OnFailure" to only restart when the VM fails
type VMSpecRestartPolicy string

// VMState defines model for VMState.
type VMState struct {
	// ObservedGeneration Corresponds to the `Generation` value on which the worker had acted upon
	ObservedGeneration *float32 `json:"observedGeneration,omitempty"`

	// Status VM status
	Status *VMStateStatus `json:"status,omitempty"`

	// StatusMessage VM status message
	StatusMessage *string `json:"status_message,omitempty"`

	// Worker Worker on which the VM was assigned to
	Worker *string `json:"worker,omitempty"`
}

// VMStateStatus VM status
type VMStateStatus string

// Worker defines model for Worker.
type Worker struct {
	// Name Node name
	Name *string `json:"name,omitempty"`

	// Resources Dictionary that maps the resource name to the
	// amount of this resource provided by the worker
	// for running VMs.
	Resources *map[string]int `json:"resources,omitempty"`
}

// PostVmsJSONBody defines parameters for PostVms.
type PostVmsJSONBody struct {
	// Cpu Number of CPUs assigned to this VM
	Cpu *float32 `json:"cpu,omitempty"`

	// DiskSize Disk size for this VM
	DiskSize *float32 `json:"diskSize,omitempty"`

	// Generation Incremented by the controller each time a VM's specification changes
	Generation *float32 `json:"generation,omitempty"`

	// Headless Whether to run without graphics
	Headless *bool `json:"headless,omitempty"`

	// HostDirs Directories on the Orchard Worker host to mount to a VM
	HostDirs *[]struct {
		Name *string `json:"name,omitempty"`
		Path *string `json:"path,omitempty"`
		Ro   *bool   `json:"ro,omitempty"`
	} `json:"hostDirs,omitempty"`

	// Image VM image for this VM
	Image *string `json:"image,omitempty"`

	// ImagePullPolicy VM image pull policy
	ImagePullPolicy *PostVmsJSONBodyImagePullPolicy `json:"imagePullPolicy,omitempty"`

	// Labels Labels required by this VM on the worker
	Labels *map[string]string `json:"labels,omitempty"`

	// Memory Amount of RAM in megabytes assigned to this VM
	Memory *float32 `json:"memory,omitempty"`

	// Name VM name
	Name *string `json:"name,omitempty"`

	// Nested Enable nested virtualization
	Nested *bool `json:"nested,omitempty"`

	// NetBridged Whether to use bridged network mode
	NetBridged *string `json:"net-bridged,omitempty"`

	// NetSoftnetDeprecated Please use `NetSoftnet` instead
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	NetSoftnetDeprecated *bool `json:"net-softnet,omitempty"`

	// NetSoftnet Whether to use Softnet network isolation.
	//
	// See `tart run`'s help for `--net-softnet` for more details.
	NetSoftnet *bool `json:"netSoftnet,omitempty"`

	// NetSoftnetAllow List of CIDRs to allow the traffic to when using Softnet isolation.
	//
	// See `tart run`'s help for `--net-softnet-allow` for more details.
	//
	// Enables `netSoftnet`.
	NetSoftnetAllow *[]string `json:"netSoftnetAllow,omitempty"`

	// NetSoftnetBlock List of CIDRs to block the traffic to when using Softnet isolation.
	//
	// See `tart run`'s help for `--net-softnet-block` for more details.
	//
	// Enables `netSoftnet`.
	NetSoftnetBlock *[]string `json:"netSoftnetBlock,omitempty"`

	// Password SSH password to use when connecting to a VM
	Password *string `json:"password,omitempty"`

	// Resources Resources required by this VM on the worker
	Resources *map[string]int `json:"resources,omitempty"`

	// RestartPolicy VM restart policy: specify "Never" to never restart or "OnFailure" to only restart when the VM fails
	RestartPolicy *PostVmsJSONBodyRestartPolicy `json:"restart_policy,omitempty"`

	// StartupScript Startup script to run after the VM boots and becomes accessible via SSH
	StartupScript *struct {
		Env           *map[string]string `json:"env,omitempty"`
		ScriptContent *string            `json:"script_content,omitempty"`
	} `json:"startup_script,omitempty"`

	// Suspendable When set, a VM will be started with an additional
	// `--suspendable` command-line argument to `tart run`,
	// which allows suspending it.
	//
	// Further generations of the VM will be `tart suspend`'ed instead of
	// `tart stopped`.
	//
	// For example, this allows you to prepare a VM with loose Softnet settings and then
	// move to the next generation by tightening the settings while preserving the VM's state.
	Suspendable *bool `json:"suspendable,omitempty"`

	// Username SSH username to use when connecting to a VM
	Username *string `json:"username,omitempty"`
}

// PostVmsJSONBodyImagePullPolicy defines parameters for PostVms.
type PostVmsJSONBodyImagePullPolicy string

// PostVmsJSONBodyRestartPolicy defines parameters for PostVms.
type PostVmsJSONBodyRestartPolicy string

// DeleteVmsNameParams defines parameters for DeleteVmsName.
type DeleteVmsNameParams struct {
	// Watch Watch for changes a VM resource and return them a stream of ADDED, MODIFIED and DELETED notifications
	Watch *bool `form:"watch,omitempty" json:"watch,omitempty"`
}

// GetVmsNameParams defines parameters for GetVmsName.
type GetVmsNameParams struct {
	// Watch Watch for changes a VM resource and return them a stream of ADDED, MODIFIED and DELETED notifications
	Watch *bool `form:"watch,omitempty" json:"watch,omitempty"`
}

// PutVmsNameParams defines parameters for PutVmsName.
type PutVmsNameParams struct {
	// Watch Watch for changes a VM resource and return them a stream of ADDED, MODIFIED and DELETED notifications
	Watch *bool `form:"watch,omitempty" json:"watch,omitempty"`
}

// GetVmsNameIpParams defines parameters for GetVmsNameIp.
type GetVmsNameIpParams struct {
	// Wait Duration in seconds to wait for the VM to transition into "running" state if not already running.
	Wait *int `form:"wait,omitempty" json:"wait,omitempty"`
}

// GetVmsNamePortForwardParams defines parameters for GetVmsNamePortForward.
type GetVmsNamePortForwardParams struct {
	// Port VM's TCP port number to connect to
	Port int `form:"port" json:"port"`

	// Wait Duration in seconds to wait for the VM to transition into "running" state if not already running.
	Wait *int `form:"wait,omitempty" json:"wait,omitempty"`

	// Connection WebSocket protocol required header
	Connection string `json:"Connection"`

	// Upgrade WebSocket protocol required header
	Upgrade string `json:"Upgrade"`
}

// GetWorkersNamePortForwardParams defines parameters for GetWorkersNamePortForward.
type GetWorkersNamePortForwardParams struct {
	// Port Worker's TCP port number to connect to
	Port int `form:"port" json:"port"`

	// Wait Duration in seconds for the worker to become available if it's not available already
	Wait *int `form:"wait,omitempty" json:"wait,omitempty"`

	// Connection WebSocket protocol required header
	Connection string `json:"Connection"`

	// Upgrade WebSocket protocol required header
	Upgrade string `json:"Upgrade"`
}

// PutClusterSettingsJSONRequestBody defines body for PutClusterSettings for application/json ContentType.
type PutClusterSettingsJSONRequestBody = ClusterSettings

// PostServiceAccountsJSONRequestBody defines body for PostServiceAccounts for application/json ContentType.
type PostServiceAccountsJSONRequestBody = ServiceAccount

// PutServiceAccountsNameJSONRequestBody defines body for PutServiceAccountsName for application/json ContentType.
type PutServiceAccountsNameJSONRequestBody = ServiceAccount

// PostVmsJSONRequestBody defines body for PostVms for application/json ContentType.
type PostVmsJSONRequestBody PostVmsJSONBody

// PutVmsNameJSONRequestBody defines body for PutVmsName for application/json ContentType.
type PutVmsNameJSONRequestBody = VMSpec

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetClusterSettings request
	GetClusterSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutClusterSettingsWithBody request with any body
	PutClusterSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutClusterSettings(ctx context.Context, body PutClusterSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetControllerInfo request
	GetControllerInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccounts request
	GetServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostServiceAccountsWithBody request with any body
	PostServiceAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostServiceAccounts(ctx context.Context, body PostServiceAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountsName request
	DeleteServiceAccountsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountsName request
	GetServiceAccountsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutServiceAccountsNameWithBody request with any body
	PutServiceAccountsNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutServiceAccountsName(ctx context.Context, name string, body PutServiceAccountsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVms request
	GetVms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVmsWithBody request with any body
	PostVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVms(ctx context.Context, body PostVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVmsName request
	DeleteVmsName(ctx context.Context, name string, params *DeleteVmsNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVmsName request
	GetVmsName(ctx context.Context, name string, params *GetVmsNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutVmsNameWithBody request with any body
	PutVmsNameWithBody(ctx context.Context, name string, params *PutVmsNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutVmsName(ctx context.Context, name string, params *PutVmsNameParams, body PutVmsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVmsNameEvents request
	GetVmsNameEvents(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVmsNameIp request
	GetVmsNameIp(ctx context.Context, name string, params *GetVmsNameIpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVmsNamePortForward request
	GetVmsNamePortForward(ctx context.Context, name string, params *GetVmsNamePortForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkers request
	GetWorkers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkersName request
	DeleteWorkersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkersName request
	GetWorkersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkersNamePortForward request
	GetWorkersNamePortForward(ctx context.Context, name string, params *GetWorkersNamePortForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetClusterSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutClusterSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClusterSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutClusterSettings(ctx context.Context, body PutClusterSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutClusterSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetControllerInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetControllerInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServiceAccounts(ctx context.Context, body PostServiceAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServiceAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountsNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountsName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountsNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutServiceAccountsNameWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutServiceAccountsNameRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutServiceAccountsName(ctx context.Context, name string, body PutServiceAccountsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutServiceAccountsNameRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVmsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVmsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVms(ctx context.Context, body PostVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVmsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVmsName(ctx context.Context, name string, params *DeleteVmsNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVmsNameRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVmsName(ctx context.Context, name string, params *GetVmsNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmsNameRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVmsNameWithBody(ctx context.Context, name string, params *PutVmsNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVmsNameRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutVmsName(ctx context.Context, name string, params *PutVmsNameParams, body PutVmsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutVmsNameRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVmsNameEvents(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmsNameEventsRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVmsNameIp(ctx context.Context, name string, params *GetVmsNameIpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmsNameIpRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVmsNamePortForward(ctx context.Context, name string, params *GetVmsNamePortForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmsNamePortForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkersNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkersName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkersNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkersNamePortForward(ctx context.Context, name string, params *GetWorkersNamePortForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkersNamePortForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetClusterSettingsRequest generates requests for GetClusterSettings
func NewGetClusterSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutClusterSettingsRequest calls the generic PutClusterSettings builder with application/json body
func NewPutClusterSettingsRequest(server string, body PutClusterSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutClusterSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPutClusterSettingsRequestWithBody generates requests for PutClusterSettings with any type of body
func NewPutClusterSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetControllerInfoRequest generates requests for GetControllerInfo
func NewGetControllerInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/controller/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountsRequest generates requests for GetServiceAccounts
func NewGetServiceAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostServiceAccountsRequest calls the generic PostServiceAccounts builder with application/json body
func NewPostServiceAccountsRequest(server string, body PostServiceAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostServiceAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostServiceAccountsRequestWithBody generates requests for PostServiceAccounts with any type of body
func NewPostServiceAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountsNameRequest generates requests for DeleteServiceAccountsName
func NewDeleteServiceAccountsNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountsNameRequest generates requests for GetServiceAccountsName
func NewGetServiceAccountsNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutServiceAccountsNameRequest calls the generic PutServiceAccountsName builder with application/json body
func NewPutServiceAccountsNameRequest(server string, name string, body PutServiceAccountsNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutServiceAccountsNameRequestWithBody(server, name, "application/json", bodyReader)
}

// NewPutServiceAccountsNameRequestWithBody generates requests for PutServiceAccountsName with any type of body
func NewPutServiceAccountsNameRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVmsRequest generates requests for GetVms
func NewGetVmsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVmsRequest calls the generic PostVms builder with application/json body
func NewPostVmsRequest(server string, body PostVmsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVmsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostVmsRequestWithBody generates requests for PostVms with any type of body
func NewPostVmsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVmsNameRequest generates requests for DeleteVmsName
func NewDeleteVmsNameRequest(server string, name string, params *DeleteVmsNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Watch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watch", runtime.ParamLocationQuery, *params.Watch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVmsNameRequest generates requests for GetVmsName
func NewGetVmsNameRequest(server string, name string, params *GetVmsNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Watch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watch", runtime.ParamLocationQuery, *params.Watch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutVmsNameRequest calls the generic PutVmsName builder with application/json body
func NewPutVmsNameRequest(server string, name string, params *PutVmsNameParams, body PutVmsNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutVmsNameRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewPutVmsNameRequestWithBody generates requests for PutVmsName with any type of body
func NewPutVmsNameRequestWithBody(server string, name string, params *PutVmsNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Watch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watch", runtime.ParamLocationQuery, *params.Watch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVmsNameEventsRequest generates requests for GetVmsNameEvents
func NewGetVmsNameEventsRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVmsNameIpRequest generates requests for GetVmsNameIp
func NewGetVmsNameIpRequest(server string, name string, params *GetVmsNameIpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s/ip", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Wait != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVmsNamePortForwardRequest generates requests for GetVmsNamePortForward
func NewGetVmsNamePortForwardRequest(server string, name string, params *GetVmsNamePortForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vms/%s/port-forward", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "port", runtime.ParamLocationQuery, params.Port); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Wait != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Connection", runtime.ParamLocationHeader, params.Connection)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Connection", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Upgrade", runtime.ParamLocationHeader, params.Upgrade)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Upgrade", headerParam1)

	}

	return req, nil
}

// NewGetWorkersRequest generates requests for GetWorkers
func NewGetWorkersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteWorkersNameRequest generates requests for DeleteWorkersName
func NewDeleteWorkersNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkersNameRequest generates requests for GetWorkersName
func NewGetWorkersNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkersNamePortForwardRequest generates requests for GetWorkersNamePortForward
func NewGetWorkersNamePortForwardRequest(server string, name string, params *GetWorkersNamePortForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/%s/port-forward", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "port", runtime.ParamLocationQuery, params.Port); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Wait != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wait", runtime.ParamLocationQuery, *params.Wait); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Connection", runtime.ParamLocationHeader, params.Connection)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Connection", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Upgrade", runtime.ParamLocationHeader, params.Upgrade)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Upgrade", headerParam1)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetClusterSettingsWithResponse request
	GetClusterSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterSettingsResponse, error)

	// PutClusterSettingsWithBodyWithResponse request with any body
	PutClusterSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClusterSettingsResponse, error)

	PutClusterSettingsWithResponse(ctx context.Context, body PutClusterSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClusterSettingsResponse, error)

	// GetControllerInfoWithResponse request
	GetControllerInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetControllerInfoResponse, error)

	// GetServiceAccountsWithResponse request
	GetServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServiceAccountsResponse, error)

	// PostServiceAccountsWithBodyWithResponse request with any body
	PostServiceAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceAccountsResponse, error)

	PostServiceAccountsWithResponse(ctx context.Context, body PostServiceAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceAccountsResponse, error)

	// DeleteServiceAccountsNameWithResponse request
	DeleteServiceAccountsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteServiceAccountsNameResponse, error)

	// GetServiceAccountsNameWithResponse request
	GetServiceAccountsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetServiceAccountsNameResponse, error)

	// PutServiceAccountsNameWithBodyWithResponse request with any body
	PutServiceAccountsNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutServiceAccountsNameResponse, error)

	PutServiceAccountsNameWithResponse(ctx context.Context, name string, body PutServiceAccountsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PutServiceAccountsNameResponse, error)

	// GetVmsWithResponse request
	GetVmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVmsResponse, error)

	// PostVmsWithBodyWithResponse request with any body
	PostVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVmsResponse, error)

	PostVmsWithResponse(ctx context.Context, body PostVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVmsResponse, error)

	// DeleteVmsNameWithResponse request
	DeleteVmsNameWithResponse(ctx context.Context, name string, params *DeleteVmsNameParams, reqEditors ...RequestEditorFn) (*DeleteVmsNameResponse, error)

	// GetVmsNameWithResponse request
	GetVmsNameWithResponse(ctx context.Context, name string, params *GetVmsNameParams, reqEditors ...RequestEditorFn) (*GetVmsNameResponse, error)

	// PutVmsNameWithBodyWithResponse request with any body
	PutVmsNameWithBodyWithResponse(ctx context.Context, name string, params *PutVmsNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVmsNameResponse, error)

	PutVmsNameWithResponse(ctx context.Context, name string, params *PutVmsNameParams, body PutVmsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PutVmsNameResponse, error)

	// GetVmsNameEventsWithResponse request
	GetVmsNameEventsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetVmsNameEventsResponse, error)

	// GetVmsNameIpWithResponse request
	GetVmsNameIpWithResponse(ctx context.Context, name string, params *GetVmsNameIpParams, reqEditors ...RequestEditorFn) (*GetVmsNameIpResponse, error)

	// GetVmsNamePortForwardWithResponse request
	GetVmsNamePortForwardWithResponse(ctx context.Context, name string, params *GetVmsNamePortForwardParams, reqEditors ...RequestEditorFn) (*GetVmsNamePortForwardResponse, error)

	// GetWorkersWithResponse request
	GetWorkersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkersResponse, error)

	// DeleteWorkersNameWithResponse request
	DeleteWorkersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteWorkersNameResponse, error)

	// GetWorkersNameWithResponse request
	GetWorkersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetWorkersNameResponse, error)

	// GetWorkersNamePortForwardWithResponse request
	GetWorkersNamePortForwardWithResponse(ctx context.Context, name string, params *GetWorkersNamePortForwardParams, reqEditors ...RequestEditorFn) (*GetWorkersNamePortForwardResponse, error)
}

type GetClusterSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
}

// Status returns HTTPResponse.Status
func (r GetClusterSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutClusterSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
}

// Status returns HTTPResponse.Status
func (r PutClusterSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutClusterSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetControllerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerInfo
}

// Status returns HTTPResponse.Status
func (r GetControllerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetControllerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ServiceAccount
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostServiceAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccount
}

// Status returns HTTPResponse.Status
func (r PostServiceAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostServiceAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccount
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutServiceAccountsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccount
}

// Status returns HTTPResponse.Status
func (r PutServiceAccountsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutServiceAccountsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VM
}

// Status returns HTTPResponse.Status
func (r GetVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VM
}

// Status returns HTTPResponse.Status
func (r PostVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVmsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVmsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVmsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VM
}

// Status returns HTTPResponse.Status
func (r GetVmsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutVmsNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VM
}

// Status returns HTTPResponse.Status
func (r PutVmsNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutVmsNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmsNameEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Events
}

// Status returns HTTPResponse.Status
func (r GetVmsNameEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmsNameEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmsNameIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IP
}

// Status returns HTTPResponse.Status
func (r GetVmsNameIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmsNameIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmsNamePortForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetVmsNamePortForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmsNamePortForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Worker
}

// Status returns HTTPResponse.Status
func (r GetWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkersNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkersNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkersNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkersNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Worker
}

// Status returns HTTPResponse.Status
func (r GetWorkersNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkersNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkersNamePortForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetWorkersNamePortForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkersNamePortForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetClusterSettingsWithResponse request returning *GetClusterSettingsResponse
func (c *ClientWithResponses) GetClusterSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterSettingsResponse, error) {
	rsp, err := c.GetClusterSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterSettingsResponse(rsp)
}

// PutClusterSettingsWithBodyWithResponse request with arbitrary body returning *PutClusterSettingsResponse
func (c *ClientWithResponses) PutClusterSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutClusterSettingsResponse, error) {
	rsp, err := c.PutClusterSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClusterSettingsResponse(rsp)
}

func (c *ClientWithResponses) PutClusterSettingsWithResponse(ctx context.Context, body PutClusterSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PutClusterSettingsResponse, error) {
	rsp, err := c.PutClusterSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutClusterSettingsResponse(rsp)
}

// GetControllerInfoWithResponse request returning *GetControllerInfoResponse
func (c *ClientWithResponses) GetControllerInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetControllerInfoResponse, error) {
	rsp, err := c.GetControllerInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetControllerInfoResponse(rsp)
}

// GetServiceAccountsWithResponse request returning *GetServiceAccountsResponse
func (c *ClientWithResponses) GetServiceAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServiceAccountsResponse, error) {
	rsp, err := c.GetServiceAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountsResponse(rsp)
}

// PostServiceAccountsWithBodyWithResponse request with arbitrary body returning *PostServiceAccountsResponse
func (c *ClientWithResponses) PostServiceAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServiceAccountsResponse, error) {
	rsp, err := c.PostServiceAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceAccountsResponse(rsp)
}

func (c *ClientWithResponses) PostServiceAccountsWithResponse(ctx context.Context, body PostServiceAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServiceAccountsResponse, error) {
	rsp, err := c.PostServiceAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServiceAccountsResponse(rsp)
}

// DeleteServiceAccountsNameWithResponse request returning *DeleteServiceAccountsNameResponse
func (c *ClientWithResponses) DeleteServiceAccountsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteServiceAccountsNameResponse, error) {
	rsp, err := c.DeleteServiceAccountsName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountsNameResponse(rsp)
}

// GetServiceAccountsNameWithResponse request returning *GetServiceAccountsNameResponse
func (c *ClientWithResponses) GetServiceAccountsNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetServiceAccountsNameResponse, error) {
	rsp, err := c.GetServiceAccountsName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountsNameResponse(rsp)
}

// PutServiceAccountsNameWithBodyWithResponse request with arbitrary body returning *PutServiceAccountsNameResponse
func (c *ClientWithResponses) PutServiceAccountsNameWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutServiceAccountsNameResponse, error) {
	rsp, err := c.PutServiceAccountsNameWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutServiceAccountsNameResponse(rsp)
}

func (c *ClientWithResponses) PutServiceAccountsNameWithResponse(ctx context.Context, name string, body PutServiceAccountsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PutServiceAccountsNameResponse, error) {
	rsp, err := c.PutServiceAccountsName(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutServiceAccountsNameResponse(rsp)
}

// GetVmsWithResponse request returning *GetVmsResponse
func (c *ClientWithResponses) GetVmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVmsResponse, error) {
	rsp, err := c.GetVms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmsResponse(rsp)
}

// PostVmsWithBodyWithResponse request with arbitrary body returning *PostVmsResponse
func (c *ClientWithResponses) PostVmsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVmsResponse, error) {
	rsp, err := c.PostVmsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVmsResponse(rsp)
}

func (c *ClientWithResponses) PostVmsWithResponse(ctx context.Context, body PostVmsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVmsResponse, error) {
	rsp, err := c.PostVms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVmsResponse(rsp)
}

// DeleteVmsNameWithResponse request returning *DeleteVmsNameResponse
func (c *ClientWithResponses) DeleteVmsNameWithResponse(ctx context.Context, name string, params *DeleteVmsNameParams, reqEditors ...RequestEditorFn) (*DeleteVmsNameResponse, error) {
	rsp, err := c.DeleteVmsName(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVmsNameResponse(rsp)
}

// GetVmsNameWithResponse request returning *GetVmsNameResponse
func (c *ClientWithResponses) GetVmsNameWithResponse(ctx context.Context, name string, params *GetVmsNameParams, reqEditors ...RequestEditorFn) (*GetVmsNameResponse, error) {
	rsp, err := c.GetVmsName(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmsNameResponse(rsp)
}

// PutVmsNameWithBodyWithResponse request with arbitrary body returning *PutVmsNameResponse
func (c *ClientWithResponses) PutVmsNameWithBodyWithResponse(ctx context.Context, name string, params *PutVmsNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutVmsNameResponse, error) {
	rsp, err := c.PutVmsNameWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVmsNameResponse(rsp)
}

func (c *ClientWithResponses) PutVmsNameWithResponse(ctx context.Context, name string, params *PutVmsNameParams, body PutVmsNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PutVmsNameResponse, error) {
	rsp, err := c.PutVmsName(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutVmsNameResponse(rsp)
}

// GetVmsNameEventsWithResponse request returning *GetVmsNameEventsResponse
func (c *ClientWithResponses) GetVmsNameEventsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetVmsNameEventsResponse, error) {
	rsp, err := c.GetVmsNameEvents(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmsNameEventsResponse(rsp)
}

// GetVmsNameIpWithResponse request returning *GetVmsNameIpResponse
func (c *ClientWithResponses) GetVmsNameIpWithResponse(ctx context.Context, name string, params *GetVmsNameIpParams, reqEditors ...RequestEditorFn) (*GetVmsNameIpResponse, error) {
	rsp, err := c.GetVmsNameIp(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmsNameIpResponse(rsp)
}

// GetVmsNamePortForwardWithResponse request returning *GetVmsNamePortForwardResponse
func (c *ClientWithResponses) GetVmsNamePortForwardWithResponse(ctx context.Context, name string, params *GetVmsNamePortForwardParams, reqEditors ...RequestEditorFn) (*GetVmsNamePortForwardResponse, error) {
	rsp, err := c.GetVmsNamePortForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmsNamePortForwardResponse(rsp)
}

// GetWorkersWithResponse request returning *GetWorkersResponse
func (c *ClientWithResponses) GetWorkersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWorkersResponse, error) {
	rsp, err := c.GetWorkers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkersResponse(rsp)
}

// DeleteWorkersNameWithResponse request returning *DeleteWorkersNameResponse
func (c *ClientWithResponses) DeleteWorkersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteWorkersNameResponse, error) {
	rsp, err := c.DeleteWorkersName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkersNameResponse(rsp)
}

// GetWorkersNameWithResponse request returning *GetWorkersNameResponse
func (c *ClientWithResponses) GetWorkersNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetWorkersNameResponse, error) {
	rsp, err := c.GetWorkersName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkersNameResponse(rsp)
}

// GetWorkersNamePortForwardWithResponse request returning *GetWorkersNamePortForwardResponse
func (c *ClientWithResponses) GetWorkersNamePortForwardWithResponse(ctx context.Context, name string, params *GetWorkersNamePortForwardParams, reqEditors ...RequestEditorFn) (*GetWorkersNamePortForwardResponse, error) {
	rsp, err := c.GetWorkersNamePortForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkersNamePortForwardResponse(rsp)
}

// ParseGetClusterSettingsResponse parses an HTTP response from a GetClusterSettingsWithResponse call
func ParseGetClusterSettingsResponse(rsp *http.Response) (*GetClusterSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutClusterSettingsResponse parses an HTTP response from a PutClusterSettingsWithResponse call
func ParsePutClusterSettingsResponse(rsp *http.Response) (*PutClusterSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutClusterSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetControllerInfoResponse parses an HTTP response from a GetControllerInfoWithResponse call
func ParseGetControllerInfoResponse(rsp *http.Response) (*GetControllerInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetControllerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountsResponse parses an HTTP response from a GetServiceAccountsWithResponse call
func ParseGetServiceAccountsResponse(rsp *http.Response) (*GetServiceAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ServiceAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostServiceAccountsResponse parses an HTTP response from a PostServiceAccountsWithResponse call
func ParsePostServiceAccountsResponse(rsp *http.Response) (*PostServiceAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostServiceAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountsNameResponse parses an HTTP response from a DeleteServiceAccountsNameWithResponse call
func ParseDeleteServiceAccountsNameResponse(rsp *http.Response) (*DeleteServiceAccountsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServiceAccountsNameResponse parses an HTTP response from a GetServiceAccountsNameWithResponse call
func ParseGetServiceAccountsNameResponse(rsp *http.Response) (*GetServiceAccountsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutServiceAccountsNameResponse parses an HTTP response from a PutServiceAccountsNameWithResponse call
func ParsePutServiceAccountsNameResponse(rsp *http.Response) (*PutServiceAccountsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutServiceAccountsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVmsResponse parses an HTTP response from a GetVmsWithResponse call
func ParseGetVmsResponse(rsp *http.Response) (*GetVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VM
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostVmsResponse parses an HTTP response from a PostVmsWithResponse call
func ParsePostVmsResponse(rsp *http.Response) (*PostVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VM
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVmsNameResponse parses an HTTP response from a DeleteVmsNameWithResponse call
func ParseDeleteVmsNameResponse(rsp *http.Response) (*DeleteVmsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVmsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVmsNameResponse parses an HTTP response from a GetVmsNameWithResponse call
func ParseGetVmsNameResponse(rsp *http.Response) (*GetVmsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VM
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/x-ndjson) unsupported

	}

	return response, nil
}

// ParsePutVmsNameResponse parses an HTTP response from a PutVmsNameWithResponse call
func ParsePutVmsNameResponse(rsp *http.Response) (*PutVmsNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutVmsNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VM
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVmsNameEventsResponse parses an HTTP response from a GetVmsNameEventsWithResponse call
func ParseGetVmsNameEventsResponse(rsp *http.Response) (*GetVmsNameEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmsNameEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Events
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVmsNameIpResponse parses an HTTP response from a GetVmsNameIpWithResponse call
func ParseGetVmsNameIpResponse(rsp *http.Response) (*GetVmsNameIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmsNameIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IP
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVmsNamePortForwardResponse parses an HTTP response from a GetVmsNamePortForwardWithResponse call
func ParseGetVmsNamePortForwardResponse(rsp *http.Response) (*GetVmsNamePortForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmsNamePortForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkersResponse parses an HTTP response from a GetWorkersWithResponse call
func ParseGetWorkersResponse(rsp *http.Response) (*GetWorkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Worker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWorkersNameResponse parses an HTTP response from a DeleteWorkersNameWithResponse call
func ParseDeleteWorkersNameResponse(rsp *http.Response) (*DeleteWorkersNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkersNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWorkersNameResponse parses an HTTP response from a GetWorkersNameWithResponse call
func ParseGetWorkersNameResponse(rsp *http.Response) (*GetWorkersNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkersNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Worker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWorkersNamePortForwardResponse parses an HTTP response from a GetWorkersNamePortForwardWithResponse call
func ParseGetWorkersNamePortForwardResponse(rsp *http.Response) (*GetWorkersNamePortForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkersNamePortForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Y5r2FrlFqj54EHl4+E8AAAD//5N5/JM6PwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
